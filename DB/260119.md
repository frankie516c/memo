2️⃣ 논리 데이터 모델 (Logical Data Model)
조금 더 쉽게 설명해 놓은 것
코멘트에 써있으면 논리 관리 중 

3️⃣ 물리 데이터 모델 (Physical Data Model)
실제 SQL에서 사용되는 것
데이터만 있으면 물리만 관리 중

2️⃣ & 3️⃣ = 1:1로 구성되어있음

스키마: **메타정보**

```
SELECT * FROM information_schema.`COLUMNS`;
SELECT * FROM information_schema.`TABLES`;
```

쿼리에서 스키마인 `information_schema` 얘를 도메인이라고 부를 수 있음 ( 스키마 > 도메인 )

<img width="225" height="437" alt="image" src="https://github.com/user-attachments/assets/2ae7ab38-cda7-477b-97e0-18d6ee70696f" />

- 뷰: 테이블이 더 빠름 (데이터 조회/권한 제어)
- 프로시져: business logic
- 함수: time zone 표기 (나라별로 시차 다르니까), 달력 만듦
- 트리거: 어떤 데이터가 조작될 때 같이 맞물린 테이블들을 트리거 시킴 (e.g., insert data -> insert data in table)
- 이벤트: 

<img width="665" height="301" alt="image" src="https://github.com/user-attachments/assets/15c9518d-0a9c-4d97-970b-d4b0a1215ccb" />

<img width="838" height="458" alt="image" src="https://github.com/user-attachments/assets/3f10f2b3-1f15-45ea-8f97-72d966d275db" />

트랜잭션: 
- insert, update, delete가 이러날 때
- 트랜잭션 A와 B를 **분리**했다는 표현이 더 정확함 (둘을 묶은게 아니라)
- SQL의 TCL안에 commit(실행)과 rollback(취소)과 연결
  - 접속된 시점부터 commit이 되어야 트랜잭션이 완료가 됨
  - 공유된 시점: commit 또는 rollback 된 시점
 
지금 정리해 둔 개념이 **절반 이상은 맞고**, 다만 DB 트랜잭션에서 자주 헷갈리는 핵심 포인트들이 조금 섞여 있어.
아래에서 **네가 적은 문장들을 하나씩 짚으면서 정확한 개념으로 다듬어 줄게.**

---

## 1. 트랜잭션의 정확한 정의

**트랜잭션(Transaction)** 이란:

> **하나의 논리적인 작업 단위**로서
> **모두 성공하거나, 모두 실패해야 하는 SQL 작업의 묶음**

* “insert / update / delete가 일어날 때” → ❌ *부분적으로만 맞음*
* 정확히는 **DML(INSERT, UPDATE, DELETE, SELECT FOR UPDATE 등)** 이 트랜잭션의 대상

✔️ **SELECT도 트랜잭션 안에 포함될 수 있음**
(단, 단순 조회는 데이터 변경이 없어서 눈에 띄지 않을 뿐)

---

## 2. “트랜잭션 A와 B를 분리했다”는 표현

> **이 표현은 방향은 맞지만, 조금 더 정확하게 말하면:**

### ❌ 잘못 이해하기 쉬운 표현

* “트랜잭션을 분리했다 = 둘을 묶은 게 아니라 나눴다”

### ✅ 정확한 개념

* 트랜잭션은 **원래 독립적인 작업 단위**
* A와 B는 **각각 다른 트랜잭션**
* DB는 이 트랜잭션들이 **서로 간섭하지 않도록 격리(Isolation)** 함

📌 즉,

> “트랜잭션을 분리했다”기보다는
> **“트랜잭션은 서로 격리된다 (Isolation)”** 가 정확한 표현

---

## 3. 트랜잭션과 COMMIT / ROLLBACK 관계 (TCL)

이 부분은 **거의 정확함**, 다만 약간의 오해가 있어.

### ✔️ 맞는 내용

* COMMIT → 변경사항 **영구 반영**
* ROLLBACK → 변경사항 **모두 취소**
* 둘 다 **TCL(Transaction Control Language)**

---

### ❌ 수정이 필요한 부분

> **“접속된 시점부터 commit이 되어야 트랜잭션이 완료”**

### ✅ 정확한 설명

* 트랜잭션은 **DB 접속 시점부터가 아니라**
* **첫 DML 실행 시점부터 시작됨**

예:

```sql
-- 여기까지는 트랜잭션 시작 아님
SELECT * FROM user;

-- 이 시점부터 트랜잭션 시작
INSERT INTO user VALUES (...);

-- 여기서 트랜잭션 종료
COMMIT;
```

📌 단, **자동 커밋(Auto-commit)** 모드에서는:

* 각 SQL 문이 **자동으로 하나의 트랜잭션**
* `INSERT → 즉시 COMMIT`

---

## 4. “공유된 시점 = commit 또는 rollback 된 시점”

이건 **아주 중요한 포인트고, 정확함** 👍

### 정확히 말하면:

* **COMMIT 전**

  * 변경 데이터는 **해당 트랜잭션에서만 보임**
* **COMMIT 후**

  * 다른 트랜잭션에서도 **공유(가시화)** 됨
* **ROLLBACK**

  * 아예 없었던 일

📌 이를 **가시성(Visibility)** 이라고 함

---

## 5. 트랜잭션의 핵심 특성: ACID

네 정리를 완성하려면 이건 반드시 붙여야 해.

| 속성          | 설명                  |
| ----------- | ------------------- |
| Atomicity   | 전부 성공 or 전부 실패      |
| Consistency | 트랜잭션 전후 무결성 유지      |
| Isolation   | 다른 트랜잭션과 격리         |
| Durability  | COMMIT 후 데이터는 영구 보존 |

---

## 6. 한 문장으로 다시 정리해보면

> **트랜잭션은 하나의 논리적 작업 단위이며,
> DML 실행 시 시작되어 COMMIT 또는 ROLLBACK으로 종료되고,
> COMMIT되기 전까지 변경 사항은 다른 트랜잭션에 보이지 않는다.**

---

## 7. 네 이해 상태 요약

| 항목                | 상태        |
| ----------------- | --------- |
| 트랜잭션 개념           | 70~80% 정확 |
| COMMIT / ROLLBACK | 거의 정확     |
| 시작 시점             | 약간 혼동     |
| 격리 개념             | 방향은 맞음    |

---

https://www.erdcloud.com/d/jYkyt5i5DyfHRaDBD

SQL에서 쿼리 만든거 복붙해오면 

**물리** ERD

<img width="980" height="1040" alt="image" src="https://github.com/user-attachments/assets/4276424f-d3c4-4990-bea4-eef27e393ed8" />

옷: 얘처럼 생긴게 多 (자식)
+: 얘처럼 생긴게 1 (부모)
데이터가 1:多 라는 것

<img width="632" height="256" alt="image" src="https://github.com/user-attachments/assets/31f2d449-753e-4be4-8f57-412d2a89d37d" />

<img width="429" height="370" alt="image" src="https://github.com/user-attachments/assets/ee637754-584c-45c2-af0e-e5c0f6486e6c" />

[inner join] 사용<br />
가능한:<br />
<img width="480" height="392" alt="image" src="https://github.com/user-attachments/assets/d39038b2-c163-4aa8-aebe-5a956deb64c0" />

정석:<br />
<img width="474" height="396" alt="image" src="https://github.com/user-attachments/assets/09696386-3ba1-4c97-8b8f-85d5692ee5ed" />

`AS e`를 사용해서 줄일 수 있음<br />
<img width="440" height="389" alt="image" src="https://github.com/user-attachments/assets/0845bcd2-3417-4aa1-a732-ad9896382521" />

`<>`: 부정<br />
<img width="381" height="316" alt="image" src="https://github.com/user-attachments/assets/562dc4ca-6c67-487e-a3f3-d3c44a1eb704" />

```
SELECT e.emp_no,
		 e.first_name,
		 e.last_name,
		 e.gender,
		 s.salary
	FROM edu.employees AS e
  INNER JOIN edu.salaries AS s
  	ON (e.emp_no = s.emp_no)
  WHERE e.gender = 'F'
	AND s.salary >= 70000
	AND s.to_date = '9999-01-01'
	;
```
이렇게 되면 중복(연봉 매년 상향)된 사람 없애줌

이 때 요구되는 부분: 데이터를 보는 눈 & SQL 작성 능력 
