Create.jsx
```
import { useState } from "react"
import { useNavigate } from "react-router"
// Create 페이지는 기존 데이터를 불러올 필요가 없기 때문에 useEffect를 사용하지 않음. 모든 입력값은 사용자가 직접 입력하면서 state가 채워짐.

const Create = () => {
  const navigate = useNavigate()
  // 생성 완료 또는 취소 시 목록 화면으로 이동하기 위해 사용.
  const [title, setTitle] = useState("")
  const [content, setContent] = useState("")
  const [accept, setAccept] = useState(0)
  // 이 부분이 디테일 페이지에 필요한건 알겠는데 여기서는 왜 필요한지 의문.
  // 새 글을 생성할 때도 승인/미승인 상태를 함께 생성하기 위한 기본값. 초기 생성 시에는 보통 '미승인(0)' 상태로 시작.
  const close = () => navigate("/")
  // 생성 취소 또는 생성 완료 후 목록 페이지로 이동
  const onsubmit = e => {
  // 폼 제출 시 새 글 데이터를 하나의 객체로 생성
    e.preventDefault()
    const data = {title, content, accept}
    console.log(data)
    // 현재는 서버나 전역 상태가 없기 때문에 콘솔에만 출력
    close()
  }

return (
    <>
        <h1 className="text-center bg-success text-dark bg-opacity-50">CREATE</h1>
        <form onSubmit={onsubmit}>
            <div className="mb-3 mt-3">
              <label htmlFor="title" className="form-label">Title:</label>
              <input type="text" className="form-control" id="title" placeholder="Enter title" name="title" required autoComplete="off" value={title} onChange={e=>setTitle(e.target.value)}/>
            </div>
            <div className="mb-3">
              <label htmlFor="content" className="form-label">Content:</label>
              <input type="text" className="form-control" id="content" placeholder="Enter content" name="content" autoComplete="off" value={content} onChange={e=>setContent(e.target.value)}/>
            </div>
            <div className="d-grid gap-2 d-md-flex justify-content-md-end">
                <button className="btn btn-primary me-md-2" type="submit">생성</button>
                <button className="btn btn-warning" type="button" onClick={close}>취소</button>
            </div>
        </form>
    </>
)
}
export default Create
```

Detail.jsx
```
import { useState, useEffect } from "react"
// useState는 컴포넌트 안에서 값(상태)을 저장하기 위한 훅
// useEffect는 컴포넌트가 화면에 처음 뜨거나 / 특정 값이 바뀔 때 실행되는 코드
// 이 코드에서 useEffect의 역할: URL로 넘어온 id를 이용해서 해당 아이템 데이터를 한 번 불러오는 용도
import { useParams, useNavigate } from "react-router"
// useParams는 URL에 들어있는 변수 값을 가져오는 훅
// useNavigate는 JS 코드로 페이지 이동을 시키기 위한 함수
import { list } from "@/data.js"
// list에서 import하는 이유는?
// 데이터가 data.js에 정적으로 있음 그래서 Detail 페이지에서도 같은 데이터(list)를 다시 불러와야 함
// 즉, List 페이지에서 쓰던 원본 데이터를 Detail 페이지에서도 그대로 쓰기 위해 import
const Detail = () => {
  const params = useParams()
  //이거의 역할: “지금 보고 있는 글이 몇 번째 글인지” 알려주는 역할
  // List.js에서 navigate(`/detail/${i}`)
  // Detail.js에서 params.id === i
  // 이 두개가 합쳐져서 밑에 useEffect에 있는 const data = list[params.id] 가 가능해지는 것
  // 정리: params로 URL 파라미터 값을 받는
  const navigate = useNavigate()
  // 초기값으로 설정해둔 뒤, 하기 사항들을 설정함
  // 밑에처럼 나눠둔 이유: 입력창을 제어 컴포넌트로 만들기 위해
  const [title, setTitle] = useState("")
  const [content, setContent] = useState("")
  const [accept, setAccept] = useState(0)
  // accept의 경우 ""가 아닌 0으로 하는 이유는? 1-승인, 2-미승인, 0-전체
  const [isEdit, setIsEdit] = useState(true)
  // 수정/저장 버튼 제어용

  const close = () => navigate("/")
  // close를 누르면 첫번째 화면으로 이동 (잘못된 id 접근 시 강제 이동)
  const onSubmit = e=> {
  // onSubmit을 누르면 event가 발생함
    e.preventDefault()
  // default 상태로 돌아가려는 것을 일단 막아줌 (form 제출 시 새로고침 막음)
    if(!isEdit) {
      return
    // 수정 버튼이 아닐 때 내용을 수정할 수 없게끔 막아주는 역할
    } else {
    const data = {title, content, accept}
  // 저장 버튼을 눌렀을 때 만들어지는 데이터
    console.log(data)
  // 지금은 서버도 DB도 없어서 콘솔에만 출력하는 것
    }
  }
  useEffect(()=>{
    const data = list[params.id]
    if(data === undefined) return close()
      //잘못된 접근을 방지하고 없는 데이터면 홈으로 돌려보냄 (위에 close = () => navigate("/"))
      setTitle(data?.title)
      setContent(data?.content)
      setAccept(data?.accept)
      //data가 존재할 때만 title을 꺼내고, data가 없으면 에러 없이 undefined를 반환하기 위한 안전장치야.
      // ?: 삼항연산자
    }, [])
    // []: 처음 렌더링 시 딱 한 번만 실행
  return (
    <>
      <h1 className="text-center bg-success text-dark bg-opacity-50">DETAIL</h1>
      <form onSubmit={onSubmit}>
        <div className="mb-3 mt-3">
          <label htmlFor="title" className="form-label">Title:</label>
          <input type="text" className="form-control" id="title" placeholder="Enter title" name="title" required autoComplete="off" readOnly={isEdit} value={title} onChange={e=>setTitle(e.target.value)} />
        </div>
        <div className="mb-3">
          <label htmlFor="content" className="form-label">Content:</label>
          <input type="text" className="form-control" id="content" placeholder="Enter content" name="content" autoComplete="off" readOnly={isEdit} value={content} onChange={e=>setContent(e.target.value)} />
        </div>
        <div className="d-grid gap-2 d-md-flex justify-content-md-end">
            <button className="btn btn-primary me-md-2" type="submit" onClick={()=>setIsEdit(!isEdit)}>{isEdit ? "수정" : "저장"}</button>
            {/* 조건문 ? "":"" -> 조건문이 맞으면 첫번째""를 적용하고, 틀리면 두번째""를 적용해라
            이 버튼의 실제 역할- 첫클릭: 수정 모드 전환, 두 번째 클릭: 저장 */}
            {
              (accept === 1) ? 
              <button className="btn btn-warning" type="button" onClick={()=>setAccept(2)}>미승인</button> :
              <button className="btn btn-success" type="button" onClick={()=>setAccept(1)}>승인</button>
            }
            <button className="btn btn-secondary" type="button" onClick={close}>취소</button>
        </div>
      </form>
    </>
  )
}

export default Detail
```

List.jsx
```
import "@/list.css"
// 일단 난 이거 안가져왔고 지금보니까 여기에 포인터 설정까지 다 있었음
import { useState, useEffect } from "react"
import { useNavigate } from "react-router"
import { list } from "@/data.js"
// 하기 정보를 import 시켜서 우리가 작업했던 const arr = [ {key}] 값을 쓰지 않아도 됨 (전 이 짓을 햇답니다 ㅋㅋ..)
// export const list = [
//   {title: "아이템1", content: "내용", accept: 1},
//   {title: "아이템2", content: "설명", accept: 2}
// ]

const List = () => {
  const navigate = useNavigate()
  const [arrs, setArrs] = useState([])
  // 배열로 만들었는데 맨 밑에 [state]을 위해 만들어둔것??
  // 정확히 말하면 화면에 실제로 보여줄 리스트라고 함. 처음에는 아무 조건도 안 눌렀으니 빈배열로 시작하는 것
  // state 값이 바뀔 때마다 list를 가공해서 arrs에 넣음 (원본 데이터list를 직접 쓰지 않고 화면용 데이터arrs를 따로 관리하는 구조)
  const [state, setState] = useState(0)
  // 0으로 해두었다는 건 전체화면으로 설정했다는 것
  // state은 지금 어떤 필터 상태인지를 나타내는 값이라고 함
  const onClick = i => navigate(`/detail/${i}`)
  useEffect(()=>{
    if(state === 1 || state === 2) {
  // 승인과 미승인 둘 중 하나일 경우 (or)로 if절을 만듦
      setArrs(list.filter(row => row.accept === state))
  // filter라는게 승인을 눌렀을 때 아이템1만 나오고 미승인을 눌렀을 때 아이템2만 나오는 설정값
  // 맞긴한데 list 전체를 돌면서 조건에 맞는 것만 새 배열로 반환 (state === 1 -> → accept === 1 인 것만 남김)
    } else {
      setArrs([...list])
  // list로 돌아가는건 알겠는데 list를 깊이 복사 한다는게 뭔 소린지 모르겠음
  // 일단 얕은 복사라고 함(GPT 피셜)
  // 새로운 배열을 만들어서 참조 주소가 달라지고 React가 “변경됨”으로 인식된다고 함
    }
  }, [state])
  // useEffect+[state]: state 값이 바뀔 때 마다 이 안의 코드를 다시 실행하라는 의미
  // 흐름: 버튼 클릭 → setState(1) 또는 setState(2) -> state 값 변경 -> useEffect 재실행 -> arrs 재계산 -> 화면 다시 렌더링
  // 만약?? [state]가 없으면?? 처음 한 번만 실행되고 버튼 눌러도 리스트가 안 바뀜
  return (
    <>
      <h1 className="text-center bg-success text-dark bg-opacity-50">LIST</h1>
      <div className="d-grid gap-2 d-md-flex justify-content-md-end">
        <button className="btn btn-secondary" type="button" onClick={()=>setState(0)}>전체</button>
        <button className="btn btn-success" type="button" onClick={()=>setState(1)}>승인</button>
{ /* 실제로 일어나는 일: 클릭 -> state = 1 -> useEffect 실행 -> filter 적용 -> setArrs(...) -> arrs.map(...) -> 화면에 승인 항목만 표시 */}
        <button className="btn btn-warning" type="button" onClick={()=>setState(2)}>미승인</button>
        <a href="/new" className="btn btn-primary">추가</a>
      </div>
      <div className="list-group mt-2 text-center">
        {
          arrs?.map((v,i) => <button key={i} className={`list-group-item m-1 display-6 ${v.accept === 1 ? "list-group-item-success" : "list-group-item-warning"}`} onClick={()=>onClick(i)}>{v.title}</button>)
          // filter은 아까 미/승인 아이템1/2를 위해 설정해둔거고 이건 다 뿌리기 위함이라고 생각하면 될지??
          // 맞긴한데 정확히는 useEffect에서 이미 필터된 arrs를 여기서는 뿌리기만 한다 (왜? map은 '판단'하는게 아니니까. '판단'은 useEffect에서 끝나니까)
        }
      </div>
    </>
  )
}

export default List
```
